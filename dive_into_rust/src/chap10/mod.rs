///
///
/// Rust是一门注重内存安全的无GC语言，borrow check是rust区别于其它语言特性
///
///
/// 一个进程在执行的时候，它所占用的内存的虚拟地址空间一般被分割成好几个区域，
/// 我们称为“段”(Segment)。
///
/// - 代码段，编译后的机器码存在的区域。一般这个段是只读的。
/// - bss段，存放未初始化的全局变量和静态变量的区域。
/// - 数据段，存放有初始化的全局变量和静态变量的区域。
/// - 函数调用栈(call stack segment)。存放函数参数、局部变量以及其他函数调用相关信息的区域。
/// - 堆(heap)。存放动态分配内存的区域。
/// - 函数调用栈(call stack)，简称栈(stack)。
///
///
/// 堆和栈的区别在于，
///
/// - 栈上保存的局部变量在退出当前作用域的时候会自动释放；
/// - 堆上分配的空间没有作用域，需要手动释放；
/// - 一般栈上分配的空间大小是编译阶段就可以确定的（C语言的VLA除外）；
/// - 栈有一个确定的最大长度，超过这个长度会产生“栈溢出”(stack overflow)；
/// - 堆的空间一般要更大一些，堆上的内存耗尽了，就会产生“内存分配不足”(out of memory)。
#[test]
fn _10_01_01_mem_manage() {


}

///
/// Rust is a systems programming language that runs blazingly fast, prevents segfaults,
/// and guarantees thread safety.
/// 什么是segfault，实际上是“segmentation fault”的缩写，即“段错误”。
///
/// segfault是这样形成的：
/// 进程空间中的每个段通过硬件MMU映射到真正的物理空间；在这个映射过程中，我们给不同的段设置不同的访问权限，比如代码段
/// 就是只能读不能写；进程在执行过程中，如果违反了这些权限，CPU会直接产生一个硬件异常；硬件异常会被操作系统内核处理，
/// 一般内核会向对应的进程发送一条信号；如果没有实现自己特殊的信号处理函数，默认情况下，这个进程会直接非正常退出；
/// 如果操作系统打开了core dump功能，在进程退出的时候操作系统会把它当时的内存状态、寄存器状态以及各种相关信息保存到
/// 一个文件中，供用户以后调试使用。
/// 传统系统级编程语言C/C++里面，制造segfault是很容易的。程序员需要非常小心才能避免这种错误，这也是为什么会有那么多的
/// 代码标准来规范程序员的行为。另外一类编程语言规避segfault的办法是使用自动来及回收机制。在这些编程语言中，指针的
/// 能力被大幅限制，内存分配和释放都在一个运行时环境中被严格管理。当然，这么做也付出了一定代价。某些场景这样的代价换取了
/// 开发效率和安全性也是可以接受的。
///
///
#[test]
fn _10_01_02_mem_segment_error() {

}

///
/// “内存不安全”的问题，就是Rust想要避免的问题
///
/// - 空指针，解引用空指针是不安全的。空指针引用大部分情况下会产生segfault。
/// - 野指针，野指针指的是未初始化的指针。它的值取决于它这个位置以前遗留的是什么值。所以它可能指向任意一个地方。对它解引用，可能会造成segfault，也可能不会，这个行为无法预测。
/// - 悬空指针，悬空指针指的是内存空间在被释放了之后，继续使用。它跟野指针类似，同样会读写已经不属于这个指针的内容。
/// - 使用未初始化内存，不仅是指针类型，任何一种类型不初始化就直接使用都是危险的，后果无法预测。
/// - 非法释放，内存分配和释放要配对。如果对同一个指针释放两次，会制造内存错误。如果指针并不是内存分配器返回的值，对其执行释放，也是危险的。
/// - 缓冲区溢出，指针访问越界了，结果也是类似野指针，会读取或修改临近内存空间的值。
/// - 执行非法函数指针，如果一个函数指针不是准确指向一个函数地址，那么调用这个函数指针会导致一段随机数据被当成指令来执行。
/// - 数据竞争，在并发场景下，针对同一块内存同时读写，且没有同步措施。
///
///
/// 另外`panic!`不属于内存安全问题，锁机制也不属于内存安全问题
///
#[test]
fn _10_01_03_mem_safe() {

}